SETMEMDATA: CPU.er.mdr = $1;
GETMEMDATA: $1 = CPU.er.mdr;
SETMEMADDR: CPU.er.mar = $1;
GETMEMADDR: $1 = CPU.er.mar;
READB: CPU.er.mdr = Cpu16_ReadB(CPU.er.mar);
READW: CPU.er.mdr = Cpu16_ReadW(CPU.er.mar);
WRITEB: Cpu16_WriteB(CPU.mar, CPU.mdr);
WRITEW: Cpu16_WriteW(CPU.mar, CPU.mdr);
PCREAD: |
  $1 = Cpu16_PcRead();
  if (CPU.er.pcNextCached)
  {
    goto $L1;
  }
COPYW: $1 = $2;
COPYB: $1 = ($2 & 0xFF);
INC: $1 = $1 + 1;
DEC: $1 = $1 - 1;
MOVEW: TODO
MOVEB: TODO
ADDW: $1 = $1 + $2;
SUBW: $1 = $1 + $2;
ADDB: $1 = ($1 + $2) & 0xFF;
SUBB: $1 = ($1 + $2) & 0xFF;
ADCW: $1 = CPU16_ADC($1, $2);
ADCB: $1 = (CPU16_ADC($1, $2) & 0xFF);
SBCW: $1 = CPU16_SBC($1, $2);
SBCB: $1 = (CPU16_SBC($1, $2) & 0xFF);
ANDW: $1 = $1 & $2;
ORW:  $1 = $1 | $2;
XORW: $1 = $1 ^ $2;
NOTW: $1 = ~$2;
ANDB: $1 = (($1 & $2) & 0xFF);
ORB:  $1 = (($1 | $2) & 0xFF);
XORB: $1 = (($1 ^ $2) & 0xFF);
NOTB: $1 = ((~$2) & 0xFF);
SHLW: $1 = $1 << $2;
SHRW: $1 = $1 >> $2;
SHLB: $1 = (($1 << $2) & 0xFF);
SHRB: $1 = (($1 >> $2) & 0xFF);
ROLW: $1 = CPU16_ROL($1, $2);
ROLB: $1 = CPU16_ROL($1, $2);
RORW: $1 = CPU16_ROR($1, $2) & 0xFF;
RORB: $1 = CPU16_ROR($1, $2) & 0xFF;
CMPW: Cpu16_CmpW($1, $2);
CMPB: Cpu16_CmpB($1, $2);
CMPBIT: Cpu16_CmpBit($1, $2);
PCADDW: Cpu16_PcAddSignedW($1);
PCADDB: Cpu16_PcAddSignedB($1);
NEXTCYCLEIF: |
  if (($1) == false)
  {
    (*subCycle) = 0x0F;
    return;
  }
FLUSH: Cpu16_Flush();
ORCF: Cpu16_OrConditionFlags($1);
ANDCF: Cpu16_AndConditionFlags($1);
FLAGS:
